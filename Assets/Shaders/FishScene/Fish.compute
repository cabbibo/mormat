#pragma kernel Flow


struct Vert{
  float3 pos;
  float3 vel;
  float3 nor;
  float3 ogPos;
  float3 axis;
  float life;
};

struct Transform {
  float4x4 localToWorld;
  float4x4 worldToLocal;
};


struct Human {
  float4x4 leftHand;
  float4x4 rightHand;
  float4x4 head;
  float leftTrigger;
  float rightTrigger;
  float voice;
  float debug;
};

RWStructuredBuffer<Human> _HumanBuffer;
int _HumanBuffer_COUNT;

RWStructuredBuffer<Vert> _VertBuffer;
RWStructuredBuffer<Vert> _SpookyBuffer;
RWStructuredBuffer<Transform> _TransformBuffer;

float4x4 _Transform;
float4x4 _Terrarium;
float4x4 _SpacePup;


int _VertBuffer_COUNT;
int _TransformBuffer_COUNT;
int _SpookyBuffer_COUNT;

#include "../Chunks/safeID.cginc"
#include "../Chunks/snoise.cginc"
#include "../Chunks/hash.cginc"
#include "../Chunks/curlNoise.cginc"
float sdBox( float3 p, float3 b )
{
  float3 d = abs(p) - b;
  return length(max(d,0.0))
         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf 
}

float map( float3 pos ){
    
    float minDist = 100000;
    
    for( int i = 0; i < _TransformBuffer_COUNT; i++ ){
      float3 newPos = mul( _TransformBuffer[i].worldToLocal , float4( pos ,1)).xyz;
      float  dist = sdBox( newPos , float3(.6,.6,.6));
      minDist = min( minDist ,dist);
    }

    return minDist;
}

float3 getNor( float3 pos ){
  float3 eps = float3(.001 , 0, 0);

  float3 nor = float3(
      map( pos + eps.xyy ) - map( pos - eps.xyy),
      map( pos + eps.yxy ) - map( pos - eps.yxy),
      map( pos + eps.yyx ) - map( pos - eps.yyx)
    );
  return normalize( nor  * 1000 );
}


float3 HumanForces(float3 p){
  float3 totalForce;
  
  for( int i = 0; i < _HumanBuffer_COUNT; i++ ){
    Human h = _HumanBuffer[i];

    float3 hL = mul(h.leftHand,float4(0,0,0,1));
    float3 hR = mul(h.rightHand,float4(0,0,0,1));
    float3 hH = mul(h.head,float4(0,0,0,1));

    float3 d;

    d = p - hL;

    if( length( d ) < 1 && length( d ) > .01 ){ 
      totalForce += normalize( d ) / length(d);
    }


     d = p - hR;
    if( length( d ) < 1 && length( d ) > .01 ){ 
      totalForce += normalize( d ) / length(d);
    }
  }

  return totalForce * .001;
}

float3 Others(int pID , float3 pos,float3 vel ){

  float3 totalForce = float3(0,0,0);


  for( int i=0; i <_VertBuffer_COUNT; i++ ){

    Vert oVert = _VertBuffer[i];
    if( i != pID ){

      float3 dif = float3(oVert.pos - pos);

      if( length(dif) > 0 ){

      //float3 c = cross(normalize(vel), normalize(oVert.vel));
      //float3 t = normalize(cross(normalize(c),normalize(vel)));


      if( length(dif) < .08 ){
       totalForce -= normalize(dif) * .03 / length(dif);
      }

      if( length(dif) < .16 ){

        if(length(oVert.vel) > 0 ){
          totalForce += normalize(oVert.vel) * .01 / length(dif);
        }
      }// * pow( (length(dif)-.1) , 3);

        if( length(dif) < .4 ){
          totalForce += normalize(dif) * .001 *clamp( length(dif-0) ,0,2);// * length(dif);// / (length(dif)-.1);
 
        }

      // totalForce += normalize(dif) * .0004;// * length(dif);// / (length(dif)-.1);
 

      }



    //  totalForce -= dif;
    }
  }

  return totalForce * .01;

}

float _Time;

#define NR_THREADS 128
[numthreads(NR_THREADS,1,1)]
void Flow(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID) {

  int pID = threadID + u3GroupID.x * NR_THREADS;

  pID = safeID(pID,_VertBuffer_COUNT);
  Vert vert = _VertBuffer[pID];

  float scale = mul( _Transform,float4(0,1,0,0)).y;
  float3 fPos = vert.pos;

  if( vert.life <= .4 ){
    fPos = mul( _Transform,float4(0,0,0,1)).xyz;
    float3 up = mul( _Transform,float4(0,1,0,0));
    float3 right = mul( _Transform,float4(1,0,0,0));
    float3 back = mul( _Transform,float4(0,0,1,0));
    fPos += 10*up   * ( hash(float(pID * 41)) - .5) * .16;//  * ( hash(float(pID * 31)) - .5) * .2;
    fPos += 10*right * ( hash(float(pID * 11)) - .5) * .16;
    fPos += 10*back  * ( hash(float(pID * 21)) - .5) * .16;

    float3 v = float3( hash(float(pID * 20)),hash(float(pID * 42)),hash(float(pID * 32)));
    v -= .5;

    vert.axis = normalize( v);
    float3 dir = normalize(mul( _Transform , float4(0,1,0,0)).xyz) * .1;
    vert.vel = 0;// (v * 1 + dir) * .001;
    vert.life = hash(float(pID)) * .5 + .5;
  }else{
    float3 force = 0;

    //force += normalize(mul( _Transform , float4(0,1,0,0)).xyz) * .0003;
    force += curlNoise( fPos * 1 + _Time * .1) * .0001;

    //force += HumanForces( fPos );
    float3 terrarium = mul( _Terrarium , float4( fPos,1)).xyz;
    float m = -sdBox( mul( _Terrarium , float4( fPos,1)).xyz , float3(.4,.4,.4));



  float3 eps = float3(.001 , 0, 0);

  float3 nor2 = float3(
      sdBox( mul( _Terrarium , float4( fPos + eps.xyy ,1)).xyz , float3(.4,.4,.4)) - sdBox( mul( _Terrarium , float4( fPos- eps.xyy ,1)).xyz , float3(.4,.4,.4)),
      sdBox( mul( _Terrarium , float4( fPos + eps.yxy ,1)).xyz , float3(.4,.4,.4)) - sdBox( mul( _Terrarium , float4( fPos- eps.yxy ,1)).xyz , float3(.4,.4,.4)),
      sdBox( mul( _Terrarium , float4( fPos + eps.yyx ,1)).xyz , float3(.4,.4,.4)) - sdBox( mul( _Terrarium , float4( fPos- eps.yyx ,1)).xyz , float3(.4,.4,.4))
    );


  for(int i = 0; i < _SpookyBuffer_COUNT; i++ ){
    Vert spooky = _SpookyBuffer[safeID(i,_SpookyBuffer_COUNT)];

    if( length(spooky.pos - vert.pos) < .3 ){ force -= 1000*spooky.pos - 1000*vert.pos; }
  }

//fPos = terrarium;
    if( m < 0 ){ force += 100*m *nor2; }


    float3 m2 =  mul( _SpacePup , float4( fPos,1)).xyz;


if( length(m2) > 0 && length(m2) < 2){
    force += 4 * normalize(m2) * (length(m2)-2);
}


    force += .1*Others( pID , fPos , vert.vel );

   force += .00006 * (mul(_Transform , float4(0,0,0,1)).xyz - fPos);
    float dist = map( fPos );
    float3 nor = getNor( fPos ); 
    if( dist < 0 ){ force += nor  * 10.1 * -(dist); }
    if( dist < .1 ){ force -= cross( nor ,float3(0,1,0)) * .001 / (1 + 1 * dist); }
    //force -=  dist * cross( nor ,float3(0,1,0)) * .004 + dist * nor * .004;
    
    if( length(force)> 1 ){ force = normalize(force) * 1;}
    if( length(vert.vel)> 1 ){ vert.vel = normalize(vert.vel) * 1;}
    vert.vel += force * .9;

    vert.vel = normalize( vert.vel) * .006;
    fPos += vert.vel;


    vert.vel *= .9;//* minDist;
    //vert.life -= .0003;
  }
  
 // vert.nor = mul(rotation(vert.axis,vert.life*20*(hash(float(pID*123)))+hash(float(pID * 23))),float4(0,0,1,0)).xyz;
  vert.pos =fPos;
  _VertBuffer[pID] = vert;

}